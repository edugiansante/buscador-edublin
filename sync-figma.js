/**
 * üîÑ Script de Sincroniza√ß√£o Figma Make ‚Üî GitHub
 * 
 * Este script mant√©m seu projeto sincronizado entre Figma Make e GitHub,
 * preservando customiza√ß√µes locais e configura√ß√µes.
 * 
 * Uso: npm run sync:figma
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Cores para output
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  bold: '\x1b[1m',
  reset: '\x1b[0m'
};

const log = {
  success: (msg) => console.log(`${colors.green}‚úÖ ${msg}${colors.reset}`),
  error: (msg) => console.log(`${colors.red}‚ùå ${msg}${colors.reset}`),
  warning: (msg) => console.log(`${colors.yellow}‚ö†Ô∏è  ${msg}${colors.reset}`),
  info: (msg) => console.log(`${colors.blue}‚ÑπÔ∏è  ${msg}${colors.reset}`),
  step: (msg) => console.log(`${colors.cyan}üîß ${msg}${colors.reset}`),
  title: (msg) => console.log(`\n${colors.bold}${colors.cyan}${msg}${colors.reset}\n`)
};

// Configura√ß√£o
const config = {
  // Arquivos que devem ser preservados durante sync
  preserveFiles: [
    '.env',
    '.env.local',
    '.env.production',
    'package.json',
    'package-lock.json',
    'yarn.lock',
    'pnpm-lock.yaml',
    '.gitignore',
    'README.md',
    'database/setup.sql',
    'scripts/',
    '.github/',
    'deploy.config.js',
    'vercel.json',
    'netlify.toml'
  ],
  
  // Diret√≥rios que podem ser sobrescritos
  syncDirectories: [
    'components/',
    'lib/',
    'styles/'
  ],
  
  // Arquivos principais que podem ser atualizados
  syncFiles: [
    'App.tsx',
    'index.html',
    'vite.config.ts',
    'tsconfig.json'
  ]
};

// Utilit√°rios
const execCommand = (command, description, options = {}) => {
  try {
    if (!options.silent) {
      log.step(`Executando: ${description}`);
    }
    const output = execSync(command, { 
      encoding: 'utf8', 
      stdio: options.silent ? 'pipe' : 'inherit',
      ...options 
    });
    if (!options.silent) {
      log.success(`${description} conclu√≠do`);
    }
    return { success: true, output };
  } catch (error) {
    if (!options.silent) {
      log.error(`${description} falhou: ${error.message}`);
    }
    return { success: false, error: error.message, output: error.stdout };
  }
};

const fileExists = (filePath) => {
  return fs.existsSync(filePath);
};

const createBackup = (timestamp) => {
  try {
    const backupBranch = `backup-sync-${timestamp}`;
    
    // Verificar se h√° mudan√ßas n√£o commitadas
    const statusResult = execCommand('git status --porcelain', 'Verifica√ß√£o status Git', { silent: true });
    
    if (statusResult.output && statusResult.output.trim()) {
      log.warning('Detectadas mudan√ßas n√£o commitadas. Criando backup...');
      
      // Criar nova branch para backup
      execCommand(`git checkout -b ${backupBranch}`, 'Cria√ß√£o branch backup');
      execCommand('git add .', 'Adi√ß√£o arquivos backup');
      execCommand(`git commit -m "üîÑ Backup autom√°tico antes da sincroniza√ß√£o Figma Make

Timestamp: ${new Date().toISOString()}
Branch: ${backupBranch}

Este backup cont√©m todas as mudan√ßas locais antes da sincroniza√ß√£o.
Para restaurar: git checkout ${backupBranch}"`, 'Commit backup');
      
      // Voltar para main
      execCommand('git checkout main', 'Volta para main');
      
      log.success(`Backup criado na branch: ${backupBranch}`);
      return backupBranch;
    } else {
      log.info('Nenhuma mudan√ßa local para backup');
      return null;
    }
  } catch (error) {
    log.error(`Falha ao criar backup: ${error.message}`);
    return null;
  }
};

const downloadFromFigma = async () => {
  log.title('üì• BAIXANDO ATUALIZA√á√ÉO DO FIGMA MAKE');
  
  // Simular download do Figma Make
  // Na implementa√ß√£o real, isso dependeria da API do Figma Make
  
  log.step('Conectando com Figma Make...');
  
  // Verificar se token est√° configurado
  const figmaToken = process.env.FIGMA_MAKE_TOKEN;
  if (!figmaToken) {
    log.warning('Token Figma Make n√£o configurado');
    log.info('Configure FIGMA_MAKE_TOKEN nas vari√°veis de ambiente');
    
    // Para desenvolvimento, simular download bem-sucedido
    if (process.env.NODE_ENV === 'development') {
      log.info('Modo desenvolvimento: Simulando download...');
      await new Promise(resolve => setTimeout(resolve, 2000));
      log.success('Download simulado conclu√≠do');
      return true;
    }
    
    return false;
  }
  
  try {
    // Aqui seria implementada a l√≥gica espec√≠fica do Figma Make
    // Exemplo de como poderia ser:
    
    /*
    const response = await fetch('https://api.figma-make.com/export', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${figmaToken}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (!response.ok) {
      throw new Error(`Figma Make API error: ${response.status}`);
    }
    
    const data = await response.blob();
    
    // Extrair arquivos baixados
    const extractPath = './figma-make-export';
    await extractZip(data, extractPath);
    
    log.success('Download do Figma Make conclu√≠do');
    return extractPath;
    */
    
    // Por enquanto, simular
    log.info('Simulando download do Figma Make...');
    await new Promise(resolve => setTimeout(resolve, 3000));
    log.success('Download simulado conclu√≠do');
    return './figma-make-export-simulation';
    
  } catch (error) {
    log.error(`Falha no download: ${error.message}`);
    return false;
  }
};

const mergeChanges = (exportPath) => {
  log.title('üîÑ APLICANDO MUDAN√áAS DO FIGMA MAKE');
  
  if (!exportPath || exportPath.includes('simulation')) {
    log.info('Modo simula√ß√£o - n√£o h√° arquivos reais para aplicar');
    
    // Simular algumas mudan√ßas para demonstra√ß√£o
    const timestamp = new Date().toISOString();
    const simulatedChange = `// √öltima sincroniza√ß√£o Figma Make: ${timestamp}\n`;
    
    // Adicionar coment√°rio ao App.tsx
    if (fileExists('App.tsx')) {
      const appContent = fs.readFileSync('App.tsx', 'utf8');
      if (!appContent.includes('√öltima sincroniza√ß√£o Figma Make:')) {
        const updatedContent = simulatedChange + appContent;
        fs.writeFileSync('App.tsx', updatedContent);
        log.success('Simula√ß√£o: App.tsx atualizado com timestamp');
      }
    }
    
    return true;
  }
  
  try {
    // Processar arquivos do export
    log.step('Analisando arquivos exportados...');
    
    const exportFiles = fs.readdirSync(exportPath, { withFileTypes: true });
    let changesApplied = 0;
    
    for (const file of exportFiles) {
      const filePath = path.join(exportPath, file.name);
      const targetPath = file.name;
      
      if (file.isDirectory()) {
        // Processar diret√≥rio
        if (config.syncDirectories.some(dir => file.name.startsWith(dir.replace('/', '')))) {
          log.step(`Sincronizando diret√≥rio: ${file.name}`);
          
          // Backup do diret√≥rio atual se existir
          if (fileExists(targetPath)) {
            execCommand(`cp -r ${targetPath} ${targetPath}.backup`, 'Backup diret√≥rio', { silent: true });
          }
          
          // Copiar novo diret√≥rio
          execCommand(`cp -r ${filePath} ${targetPath}`, 'C√≥pia diret√≥rio', { silent: true });
          changesApplied++;
        }
      } else {
        // Processar arquivo
        if (config.syncFiles.includes(file.name)) {
          log.step(`Sincronizando arquivo: ${file.name}`);
          
          // Backup do arquivo atual se existir
          if (fileExists(targetPath)) {
            execCommand(`cp ${targetPath} ${targetPath}.backup`, 'Backup arquivo', { silent: true });
          }
          
          // Copiar novo arquivo
          execCommand(`cp ${filePath} ${targetPath}`, 'C√≥pia arquivo', { silent: true });
          changesApplied++;
        } else if (config.preserveFiles.includes(file.name)) {
          log.info(`Preservando arquivo: ${file.name}`);
        } else {
          log.warning(`Arquivo n√£o reconhecido: ${file.name}`);
        }
      }
    }
    
    log.success(`${changesApplied} mudan√ßas aplicadas`);
    return changesApplied > 0;
    
  } catch (error) {
    log.error(`Falha ao aplicar mudan√ßas: ${error.message}`);
    return false;
  }
};

const validateChanges = () => {
  log.title('üîç VALIDANDO MUDAN√áAS');
  
  let validationsPassed = 0;
  let totalValidations = 0;
  
  // Verificar se App.tsx existe e √© v√°lido
  totalValidations++;
  if (fileExists('App.tsx')) {
    try {
      const content = fs.readFileSync('App.tsx', 'utf8');
      if (content.includes('export default function App')) {
        log.success('App.tsx v√°lido');
        validationsPassed++;
      } else {
        log.warning('App.tsx pode estar corrompido');
      }
    } catch (error) {
      log.error('Erro ao ler App.tsx');
    }
  } else {
    log.error('App.tsx n√£o encontrado');
  }
  
  // Verificar estrutura de componentes
  totalValidations++;
  if (fileExists('components')) {
    const componentFiles = fs.readdirSync('components').filter(f => f.endsWith('.tsx'));
    if (componentFiles.length > 0) {
      log.success(`${componentFiles.length} componentes encontrados`);
      validationsPassed++;
    } else {
      log.warning('Nenhum componente .tsx encontrado');
    }
  } else {
    log.warning('Diret√≥rio components n√£o encontrado');
  }
  
  // Verificar se projeto builda
  totalValidations++;
  log.step('Testando build do projeto...');
  const buildResult = execCommand('npm run build', 'Build test', { silent: true });
  if (buildResult.success) {
    log.success('Build funcionando');
    validationsPassed++;
  } else {
    log.error('Build falhou - verifique erros');
  }
  
  // Verificar linting
  totalValidations++;
  log.step('Executando linter...');
  const lintResult = execCommand('npm run lint', 'Lint test', { silent: true });
  if (lintResult.success) {
    log.success('Linting aprovado');
    validationsPassed++;
  } else {
    log.warning('Avisos de linting encontrados');
    validationsPassed++; // N√£o bloquear por warnings
  }
  
  const successRate = (validationsPassed / totalValidations) * 100;
  log.info(`Valida√ß√µes: ${validationsPassed}/${totalValidations} (${successRate.toFixed(0)}%)`);
  
  return successRate >= 75; // Aceitar se 75% das valida√ß√µes passaram
};

const commitChanges = (backupBranch) => {
  log.title('üìù COMMITANDO MUDAN√áAS');
  
  // Verificar se h√° mudan√ßas para commit
  const statusResult = execCommand('git status --porcelain', 'Verifica√ß√£o status Git', { silent: true });
  
  if (!statusResult.output || !statusResult.output.trim()) {
    log.info('Nenhuma mudan√ßa detectada para commit');
    return false;
  }
  
  try {
    // Adicionar arquivos modificados
    execCommand('git add .', 'Adi√ß√£o arquivos');
    
    // Criar mensagem de commit detalhada
    const timestamp = new Date().toISOString();
    const commitMessage = `üîÑ Sync: Atualiza√ß√£o autom√°tica do Figma Make

üïí Timestamp: ${timestamp}
üîß Fonte: Figma Make automatic sync
üìã Arquivos atualizados: ${statusResult.output.split('\n').length - 1} arquivos

Detalhes das mudan√ßas:
${statusResult.output.split('\n').slice(0, 10).map(line => `- ${line.trim()}`).join('\n')}
${statusResult.output.split('\n').length > 10 ? '- ... e mais arquivos' : ''}

${backupBranch ? `üîÑ Backup dispon√≠vel em: ${backupBranch}` : ''}

Para reverter: git revert HEAD
Para ver mudan√ßas: git show HEAD`;
    
    // Fazer commit
    execCommand(`git commit -m "${commitMessage}"`, 'Commit sincroniza√ß√£o');
    
    log.success('Mudan√ßas commitadas com sucesso');
    return true;
    
  } catch (error) {
    log.error(`Falha no commit: ${error.message}`);
    return false;
  }
};

const pushToGitHub = () => {
  log.title('üöÄ ENVIANDO PARA GITHUB');
  
  try {
    // Verificar se h√° remote configurado
    const remoteResult = execCommand('git remote -v', 'Verifica√ß√£o remote', { silent: true });
    
    if (!remoteResult.output || !remoteResult.output.includes('origin')) {
      log.warning('Remote origin n√£o configurado');
      log.info('Configure primeiro: git remote add origin SEU_REPO_URL');
      return false;
    }
    
    // Push para GitHub
    const pushResult = execCommand('git push origin main', 'Push para GitHub');
    
    if (pushResult.success) {
      log.success('C√≥digo enviado para GitHub com sucesso');
      log.info('GitHub Actions iniciar√° deploy autom√°tico...');
      return true;
    } else {
      log.error('Falha no push para GitHub');
      return false;
    }
    
  } catch (error) {
    log.error(`Erro no push: ${error.message}`);
    return false;
  }
};

const notifyCompletion = (success, backupBranch) => {
  log.title('üìä SINCRONIZA√á√ÉO CONCLU√çDA');
  
  if (success) {
    console.log(`${colors.green}‚úÖ Sincroniza√ß√£o Figma Make ‚Üí GitHub realizada com sucesso!${colors.reset}\n`);
    
    console.log(`${colors.cyan}üìã Resumo:${colors.reset}`);
    console.log(`${colors.green}‚úÖ Download do Figma Make${colors.reset}`);
    console.log(`${colors.green}‚úÖ Mudan√ßas aplicadas${colors.reset}`);
    console.log(`${colors.green}‚úÖ Valida√ß√µes aprovadas${colors.reset}`);
    console.log(`${colors.green}‚úÖ Commit realizado${colors.reset}`);
    console.log(`${colors.green}‚úÖ Push para GitHub${colors.reset}`);
    
    if (backupBranch) {
      console.log(`\n${colors.cyan}üîÑ Backup dispon√≠vel:${colors.reset}`);
      console.log(`   Branch: ${backupBranch}`);
      console.log(`   Restaurar: git checkout ${backupBranch}`);
    }
    
    console.log(`\n${colors.cyan}üöÄ Pr√≥ximos passos:${colors.reset}`);
    console.log(`${colors.yellow}1. GitHub Actions executar√° deploy autom√°tico${colors.reset}`);
    console.log(`${colors.yellow}2. Verifique status em: GitHub ‚Üí Actions${colors.reset}`);
    console.log(`${colors.yellow}3. Site atualizado estar√° dispon√≠vel em alguns minutos${colors.reset}`);
    
  } else {
    console.log(`${colors.red}‚ùå Sincroniza√ß√£o falhou${colors.reset}\n`);
    
    console.log(`${colors.cyan}üîß A√ß√µes de recupera√ß√£o:${colors.reset}`);
    console.log(`${colors.yellow}1. Verifique logs de erro acima${colors.reset}`);
    console.log(`${colors.yellow}2. Execute verifica√ß√£o: npm run migrate${colors.reset}`);
    console.log(`${colors.yellow}3. Tente sincroniza√ß√£o manual${colors.reset}`);
    
    if (backupBranch) {
      console.log(`${colors.yellow}4. Se necess√°rio, restaure backup: git checkout ${backupBranch}${colors.reset}`);
    }
  }
  
  console.log(`\n${colors.cyan}üìû Suporte:${colors.reset}`);
  console.log(`   Issues: GitHub Issues`);
  console.log(`   Docs: FIGMA_GITHUB_INTEGRATION.md`);
};

// Fun√ß√£o principal
async function syncWithFigma() {
  console.log(`${colors.bold}${colors.cyan}`);
  console.log('================================================================');
  console.log('üîÑ SINCRONIZA√á√ÉO FIGMA MAKE ‚Üî GITHUB');
  console.log('================================================================');
  console.log(`${colors.reset}\n`);
  
  const timestamp = new Date().toISOString().slice(0, 16).replace(/[:.]/g, '-');
  let backupBranch = null;
  let success = false;
  
  try {
    // 1. Criar backup se necess√°rio
    backupBranch = createBackup(timestamp);
    
    // 2. Baixar atualiza√ß√£o do Figma Make
    const exportPath = await downloadFromFigma();
    if (!exportPath) {
      throw new Error('Falha no download do Figma Make');
    }
    
    // 3. Aplicar mudan√ßas
    const changesApplied = mergeChanges(exportPath);
    if (!changesApplied) {
      log.info('Nenhuma mudan√ßa aplicada - projeto j√° atualizado');
      success = true;
      return;
    }
    
    // 4. Validar mudan√ßas
    const validationPassed = validateChanges();
    if (!validationPassed) {
      throw new Error('Valida√ß√µes falharam - projeto pode estar corrompido');
    }
    
    // 5. Commit mudan√ßas
    const commitSuccess = commitChanges(backupBranch);
    if (!commitSuccess) {
      throw new Error('Falha no commit das mudan√ßas');
    }
    
    // 6. Push para GitHub
    const pushSuccess = pushToGitHub();
    if (!pushSuccess) {
      throw new Error('Falha no push para GitHub');
    }
    
    success = true;
    
  } catch (error) {
    log.error(`Erro durante sincroniza√ß√£o: ${error.message}`);
    
    // Tentar rollback se houve commit
    try {
      const hasNewCommit = execCommand('git log --oneline -1', 'Check last commit', { silent: true });
      if (hasNewCommit.success && hasNewCommit.output.includes('Sync: Atualiza√ß√£o autom√°tica')) {
        log.warning('Fazendo rollback do commit de sincroniza√ß√£o...');
        execCommand('git reset --hard HEAD~1', 'Rollback commit');
        log.success('Rollback realizado');
      }
    } catch (rollbackError) {
      log.error('Falha no rollback autom√°tico');
    }
    
    success = false;
  }
  
  // 7. Notificar conclus√£o
  notifyCompletion(success, backupBranch);
  
  return success;
}

// Executar se chamado diretamente
if (require.main === module) {
  syncWithFigma().then(success => {
    process.exit(success ? 0 : 1);
  }).catch(error => {
    log.error(`Erro inesperado: ${error.message}`);
    process.exit(1);
  });
}

module.exports = { syncWithFigma };