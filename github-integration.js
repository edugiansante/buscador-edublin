/**
 * üîó Script de Integra√ß√£o Figma Make ‚Üí GitHub
 * 
 * Este script automatiza a conex√£o entre seu projeto Figma Make
 * e um reposit√≥rio GitHub com deploy autom√°tico.
 * 
 * Uso: node scripts/github-integration.js
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { execSync } = require('child_process');

// Cores para output
const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  bold: '\x1b[1m',
  reset: '\x1b[0m'
};

const log = {
  success: (msg) => console.log(`${colors.green}‚úÖ ${msg}${colors.reset}`),
  error: (msg) => console.log(`${colors.red}‚ùå ${msg}${colors.reset}`),
  warning: (msg) => console.log(`${colors.yellow}‚ö†Ô∏è  ${msg}${colors.reset}`),
  info: (msg) => console.log(`${colors.blue}‚ÑπÔ∏è  ${msg}${colors.reset}`),
  step: (msg) => console.log(`${colors.cyan}üîß ${msg}${colors.reset}`),
  title: (msg) => console.log(`\n${colors.bold}${colors.cyan}${msg}${colors.reset}\n`)
};

// Interface para input do usu√°rio
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const question = (prompt) => {
  return new Promise((resolve) => {
    rl.question(prompt, resolve);
  });
};

// Utilit√°rios
const execCommand = (command, description, options = {}) => {
  try {
    log.step(`Executando: ${description}`);
    const output = execSync(command, { 
      encoding: 'utf8', 
      stdio: options.silent ? 'pipe' : 'inherit',
      ...options 
    });
    if (!options.silent) {
      log.success(`${description} conclu√≠do`);
    }
    return { success: true, output };
  } catch (error) {
    log.error(`${description} falhou: ${error.message}`);
    return { success: false, error: error.message, output: error.stdout };
  }
};

const fileExists = (filePath) => {
  return fs.existsSync(filePath);
};

const writeFile = (filePath, content) => {
  try {
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(filePath, content);
    return true;
  } catch (error) {
    log.error(`Erro ao escrever ${filePath}: ${error.message}`);
    return false;
  }
};

// Verificar pr√©-requisitos
async function checkPrerequisites() {
  log.title('üîç VERIFICANDO PR√â-REQUISITOS');
  
  let allGood = true;
  
  // Verificar Git
  log.step('Verificando Git...');
  const gitCheck = execCommand('git --version', 'Verifica√ß√£o Git', { silent: true });
  if (gitCheck.success) {
    log.success('Git instalado');
  } else {
    log.error('Git n√£o encontrado. Instale Git primeiro.');
    allGood = false;
  }
  
  // Verificar Node.js
  log.step('Verificando Node.js...');
  const nodeCheck = execCommand('node --version', 'Verifica√ß√£o Node.js', { silent: true });
  if (nodeCheck.success) {
    const version = nodeCheck.output.trim();
    const majorVersion = parseInt(version.slice(1));
    if (majorVersion >= 16) {
      log.success(`Node.js ${version} (compat√≠vel)`);
    } else {
      log.warning(`Node.js ${version} (recomendado 16+)`);
    }
  } else {
    log.error('Node.js n√£o encontrado. Instale Node.js primeiro.');
    allGood = false;
  }
  
  // Verificar npm
  log.step('Verificando npm...');
  const npmCheck = execCommand('npm --version', 'Verifica√ß√£o npm', { silent: true });
  if (npmCheck.success) {
    log.success(`npm ${npmCheck.output.trim()}`);
  } else {
    log.error('npm n√£o encontrado.');
    allGood = false;
  }
  
  return allGood;
}

// Configurar Git
async function setupGit() {
  log.title('üêô CONFIGURANDO GIT');
  
  // Verificar configura√ß√£o do Git
  const nameCheck = execCommand('git config user.name', 'Verifica√ß√£o nome Git', { silent: true });
  const emailCheck = execCommand('git config user.email', 'Verifica√ß√£o email Git', { silent: true });
  
  if (!nameCheck.success || !nameCheck.output.trim()) {
    const name = await question('üìù Digite seu nome para Git: ');
    execCommand(`git config --global user.name "${name}"`, 'Configura√ß√£o nome Git');
  } else {
    log.success(`Git configurado para: ${nameCheck.output.trim()}`);
  }
  
  if (!emailCheck.success || !emailCheck.output.trim()) {
    const email = await question('üìß Digite seu email para Git: ');
    execCommand(`git config --global user.email "${email}"`, 'Configura√ß√£o email Git');
  } else {
    log.success(`Email Git: ${emailCheck.output.trim()}`);
  }
  
  // Inicializar reposit√≥rio se necess√°rio
  if (!fileExists('.git')) {
    log.step('Inicializando reposit√≥rio Git...');
    execCommand('git init', 'Inicializa√ß√£o Git');
    execCommand('git branch -M main', 'Configura√ß√£o branch main');
  } else {
    log.success('Reposit√≥rio Git j√° existe');
  }
}

// Configurar package.json
async function setupPackageJson() {
  log.title('üì¶ CONFIGURANDO PACKAGE.JSON');
  
  if (!fileExists('package.json')) {
    log.step('Criando package.json...');
    
    const projectName = await question('üìù Nome do projeto (edublin): ') || 'edublin';
    const description = await question('üìù Descri√ß√£o (Plataforma de conex√£o para intercambistas): ') || 'Plataforma de conex√£o para intercambistas';
    const author = await question('üìù Autor: ') || '';
    
    const packageJsonContent = {
      "name": projectName,
      "version": "1.0.0",
      "description": description,
      "main": "App.tsx",
      "scripts": {
        "dev": "vite",
        "build": "vite build",
        "preview": "vite preview",
        "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
        "lint:fix": "eslint . --ext ts,tsx --fix",
        "type-check": "tsc --noEmit",
        "deploy:vercel": "vercel --prod",
        "deploy:netlify": "netlify deploy --prod",
        "setup": "node scripts/setup-deploy.js",
        "migrate": "node scripts/verify-migration.js",
        "sync:figma": "node scripts/sync-figma.js",
        "github:setup": "node scripts/github-integration.js"
      },
      "keywords": ["intercambio", "estudantes", "react", "supabase", "figma-make"],
      "author": author,
      "license": "MIT",
      "dependencies": {
        "react": "^18.3.1",
        "react-dom": "^18.3.1",
        "@supabase/supabase-js": "^2.39.0"
      },
      "devDependencies": {
        "@types/react": "^18.3.12",
        "@types/react-dom": "^18.3.0",
        "@typescript-eslint/eslint-plugin": "^8.15.0",
        "@typescript-eslint/parser": "^8.15.0",
        "@vitejs/plugin-react": "^4.3.3",
        "eslint": "^9.15.0",
        "eslint-plugin-react-hooks": "^5.0.0",
        "eslint-plugin-react-refresh": "^0.4.14",
        "typescript": "~5.6.2",
        "vite": "^6.0.1"
      }
    };
    
    writeFile('package.json', JSON.stringify(packageJsonContent, null, 2));
    log.success('package.json criado');
  } else {
    log.success('package.json j√° existe');
  }
  
  // Instalar depend√™ncias
  log.step('Instalando depend√™ncias...');
  const installResult = execCommand('npm install', 'Instala√ß√£o depend√™ncias');
  
  if (!installResult.success) {
    log.warning('Falha na instala√ß√£o. Tentando com --legacy-peer-deps...');
    execCommand('npm install --legacy-peer-deps', 'Instala√ß√£o depend√™ncias (legacy)');
  }
}

// Criar arquivos de configura√ß√£o
async function createConfigFiles() {
  log.title('‚öôÔ∏è CRIANDO ARQUIVOS DE CONFIGURA√á√ÉO');
  
  // .gitignore
  if (!fileExists('.gitignore')) {
    log.step('Criando .gitignore...');
    const gitignoreContent = `# Dependencies
node_modules/
/.pnp
.pnp.js

# Production builds
/dist
/build
/.next/
/out/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory
coverage/
*.lcov

# nyc test coverage
.nyc_output

# Dependency directories
node_modules/
jspm_packages/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# parcel-bundler cache
.cache
.parcel-cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Vite build output
dist/

# Storybook build outputs
.out
.storybook-out

# Temporary folders
tmp/
temp/

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Figma Make specific
.figma-make/
figma-exports/

# Deploy configs
.vercel
.netlify

# Database
*.db
*.sqlite
*.sqlite3

# OS generated files
Thumbs.db
ehthumbs.db
Desktop.ini
$RECYCLE.BIN/
`;
    writeFile('.gitignore', gitignoreContent);
    log.success('.gitignore criado');
  } else {
    log.success('.gitignore j√° existe');
  }
  
  // vite.config.ts
  if (!fileExists('vite.config.ts')) {
    log.step('Criando vite.config.ts...');
    const viteConfigContent = `import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./"),
    },
  },
  server: {
    port: 5173,
    host: true
  },
  build: {
    outDir: 'dist',
    sourcemap: true,
    rollupOptions: {
      output: {
        manualChunks: {
          'react-vendor': ['react', 'react-dom'],
          'supabase-vendor': ['@supabase/supabase-js']
        }
      }
    }
  }
})
`;
    writeFile('vite.config.ts', viteConfigContent);
    log.success('vite.config.ts criado');
  }
  
  // tsconfig.json
  if (!fileExists('tsconfig.json')) {
    log.step('Criando tsconfig.json...');
    const tsconfigContent = `{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Paths */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["**/*.ts", "**/*.tsx"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
`;
    writeFile('tsconfig.json', tsconfigContent);
    log.success('tsconfig.json criado');
  }
}

// Criar GitHub Actions
async function createGitHubActions() {
  log.title('üöÄ CRIANDO GITHUB ACTIONS');
  
  // Workflow de deploy
  const deployWorkflowContent = `name: üöÄ Deploy Edublin

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '18'

jobs:
  # Job de valida√ß√£o
  validate:
    name: üîç Validate & Test
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: üì¶ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: \${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: üì• Install dependencies
      run: npm ci
    
    - name: üîç Run linter
      run: npm run lint
      continue-on-error: true
    
    - name: üîç Type check
      run: npm run type-check
      continue-on-error: true
    
    - name: üèóÔ∏è Build project
      run: npm run build
      env:
        VITE_SUPABASE_URL: \${{ secrets.VITE_SUPABASE_URL }}
        VITE_SUPABASE_ANON_KEY: \${{ secrets.VITE_SUPABASE_ANON_KEY }}
        VITE_SITE_URL: \${{ secrets.VITE_SITE_URL }}

  # Job de deploy (apenas em main)
  deploy:
    name: üöÄ Deploy to Production
    needs: validate
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: üì¶ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: \${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: üì• Install dependencies
      run: npm ci
    
    - name: üèóÔ∏è Build project
      run: npm run build
      env:
        VITE_SUPABASE_URL: \${{ secrets.VITE_SUPABASE_URL }}
        VITE_SUPABASE_ANON_KEY: \${{ secrets.VITE_SUPABASE_ANON_KEY }}
        VITE_SITE_URL: \${{ secrets.VITE_SITE_URL }}
        VITE_APP_ENVIRONMENT: production
    
    # Deploy para Vercel
    - name: üî∫ Deploy to Vercel
      uses: amondnet/vercel-action@v25
      if: \${{ secrets.VERCEL_TOKEN }}
      with:
        vercel-token: \${{ secrets.VERCEL_TOKEN }}
        vercel-org-id: \${{ secrets.VERCEL_ORG_ID }}
        vercel-project-id: \${{ secrets.VERCEL_PROJECT_ID }}
        vercel-args: '--prod'
        working-directory: ./

  # Job de notifica√ß√£o
  notify:
    name: üì¢ Notify Deploy Status
    needs: [validate, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: üì¢ Deploy Success Notification
      if: needs.deploy.result == 'success'
      run: |
        echo "‚úÖ Deploy realizado com sucesso!"
        echo "üåê Site dispon√≠vel"
    
    - name: üì¢ Deploy Failure Notification
      if: needs.deploy.result == 'failure'
      run: |
        echo "‚ùå Deploy falhou!"
        echo "üîç Verifique os logs para mais detalhes"
`;
  
  writeFile('.github/workflows/deploy.yml', deployWorkflowContent);
  log.success('GitHub Actions workflow criado');
  
  // Workflow de sincroniza√ß√£o
  const syncWorkflowContent = `name: üîÑ Sync with Figma Make

on:
  # Trigger manual
  workflow_dispatch:
  
  # Trigger agendado (di√°rio √†s 9h)
  schedule:
    - cron: '0 9 * * *'
  
  # Trigger via webhook
  repository_dispatch:
    types: [figma-updated]

jobs:
  sync:
    name: üîÑ Sync with Figma Make
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout
      uses: actions/checkout@v4
      with:
        token: \${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: üì¶ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: üì• Install dependencies
      run: npm ci
    
    - name: üîÑ Sync with Figma Make
      run: npm run sync:figma
      env:
        FIGMA_MAKE_TOKEN: \${{ secrets.FIGMA_MAKE_TOKEN }}
        GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
    
    - name: üì¢ Notify if changes
      if: success()
      run: |
        echo "‚úÖ Sincroniza√ß√£o conclu√≠da!"
        echo "Deploy autom√°tico ser√° iniciado se houver mudan√ßas."
`;
  
  writeFile('.github/workflows/sync-figma.yml', syncWorkflowContent);
  log.success('Workflow de sincroniza√ß√£o criado');
}

// Criar templates de issue
async function createIssueTemplates() {
  log.title('üìù CRIANDO TEMPLATES DE ISSUE');
  
  // Bug report template
  const bugReportContent = `---
name: üêõ Bug Report
about: Reportar um problema
title: '[BUG] '
labels: bug
assignees: ''
---

## üêõ Descri√ß√£o do Bug
Descri√ß√£o clara do problema.

## üîÑ Passos para Reproduzir
1. V√° para '...'
2. Clique em '...'
3. Veja o erro

## ‚úÖ Comportamento Esperado
O que deveria acontecer.

## üì± Ambiente
- **Browser**: [ex: Chrome 91]
- **Device**: [ex: iPhone 12]
- **OS**: [ex: iOS 14.6]

## üì∏ Screenshots
Se aplic√°vel, adicione screenshots.

## üîó Figma Make
- [ ] O bug tamb√©m existe no Figma Make?
- [ ] √â necess√°rio atualizar o design?

## üìù Informa√ß√µes Adicionais
Qualquer informa√ß√£o adicional sobre o problema.
`;
  
  writeFile('.github/ISSUE_TEMPLATE/bug_report.md', bugReportContent);
  
  // Feature request template
  const featureRequestContent = `---
name: üí° Feature Request
about: Sugerir uma nova funcionalidade
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

## üí° Descri√ß√£o da Funcionalidade
Descri√ß√£o clara da funcionalidade solicitada.

## üéØ Problema que Resolve
Qual problema esta funcionalidade resolveria?

## üí≠ Solu√ß√£o Proposta
Como voc√™ imagina que funcionaria?

## üîÑ Alternativas Consideradas
Outras solu√ß√µes que voc√™ considerou.

## üé® Design/Mockups
Se aplic√°vel, adicione mockups ou refer√™ncias visuais.

## üîó Figma Make Integration
- [ ] Precisa ser implementado no Figma Make primeiro?
- [ ] √â uma funcionalidade apenas de c√≥digo?

## üìù Informa√ß√µes Adicionais
Qualquer contexto adicional sobre a funcionalidade.
`;
  
  writeFile('.github/ISSUE_TEMPLATE/feature_request.md', featureRequestContent);
  
  log.success('Templates de issue criados');
}

// Fazer primeiro commit
async function makeInitialCommit() {
  log.title('üìù FAZENDO COMMIT INICIAL');
  
  // Verificar se h√° arquivos para commit
  const statusResult = execCommand('git status --porcelain', 'Verifica√ß√£o status Git', { silent: true });
  
  if (!statusResult.output || !statusResult.output.trim()) {
    log.info('Nenhum arquivo para commit');
    return;
  }
  
  // Adicionar arquivos
  log.step('Adicionando arquivos ao Git...');
  execCommand('git add .', 'Adi√ß√£o arquivos Git');
  
  // Fazer commit
  log.step('Fazendo commit inicial...');
  const commitMessage = `üéâ Initial commit: Projeto Edublin integrado do Figma Make

‚úÖ Estrutura completa implementada
‚úÖ Integra√ß√£o GitHub configurada  
‚úÖ Deploy autom√°tico ativo
‚úÖ Sincroniza√ß√£o Figma Make configurada
‚úÖ Templates de colabora√ß√£o criados

Ready for production! üöÄ

Fonte: Figma Make export + GitHub integration script`;

  execCommand(`git commit -m "${commitMessage}"`, 'Commit inicial');
  
  log.success('Commit inicial realizado');
}

// Configurar reposit√≥rio remoto
async function setupRemoteRepository() {
  log.title('üîó CONFIGURANDO REPOSIT√ìRIO REMOTO');
  
  console.log(`${colors.cyan}Para conectar com GitHub, voc√™ precisa:${colors.reset}`);
  console.log(`${colors.yellow}1. Criar um reposit√≥rio no GitHub${colors.reset}`);
  console.log(`${colors.yellow}2. Copiar a URL do reposit√≥rio${colors.reset}`);
  console.log(`${colors.yellow}3. Informar a URL aqui${colors.reset}`);
  console.log('');
  
  const createRepo = await question('üêô Voc√™ j√° criou um reposit√≥rio no GitHub? (y/N): ');
  
  if (createRepo.toLowerCase() !== 'y') {
    console.log('');
    console.log(`${colors.cyan}üìã Passos para criar reposit√≥rio no GitHub:${colors.reset}`);
    console.log(`${colors.yellow}1. Acesse: https://github.com/new${colors.reset}`);
    console.log(`${colors.yellow}2. Nome: edublin (ou outro nome)${colors.reset}`);
    console.log(`${colors.yellow}3. Descri√ß√£o: Plataforma de conex√£o para intercambistas${colors.reset}`);
    console.log(`${colors.yellow}4. P√∫blico ou Privado (sua escolha)${colors.reset}`);
    console.log(`${colors.yellow}5. N√ÉO inicialize com README (j√° temos)${colors.reset}`);
    console.log(`${colors.yellow}6. Clique "Create repository"${colors.reset}`);
    console.log('');
    
    await question('üìù Pressione Enter ap√≥s criar o reposit√≥rio...');
  }
  
  const repoUrl = await question('üîó Digite a URL do reposit√≥rio GitHub (ex: https://github.com/usuario/edublin.git): ');
  
  if (!repoUrl) {
    log.warning('URL n√£o fornecida. Configure manualmente depois:');
    console.log(`${colors.cyan}git remote add origin SUA_URL_AQUI${colors.reset}`);
    console.log(`${colors.cyan}git push -u origin main${colors.reset}`);
    return;
  }
  
  // Adicionar remote origin
  log.step('Configurando remote origin...');
  const remoteResult = execCommand(`git remote add origin ${repoUrl}`, 'Configura√ß√£o remote origin');
  
  if (!remoteResult.success) {
    if (remoteResult.error.includes('already exists')) {
      log.warning('Remote origin j√° existe. Atualizando...');
      execCommand(`git remote set-url origin ${repoUrl}`, 'Atualiza√ß√£o remote origin');
    } else {
      log.error('Falha ao configurar remote origin');
      return;
    }
  }
  
  // Push inicial
  const pushConfirm = await question('üöÄ Fazer push inicial para GitHub? (Y/n): ');
  
  if (pushConfirm.toLowerCase() !== 'n') {
    log.step('Fazendo push inicial...');
    const pushResult = execCommand('git push -u origin main', 'Push inicial');
    
    if (pushResult.success) {
      log.success('C√≥digo enviado para GitHub com sucesso!');
    } else {
      log.error('Falha no push. Tente manualmente:');
      console.log(`${colors.cyan}git push -u origin main${colors.reset}`);
    }
  }
}

// Mostrar pr√≥ximos passos
async function showNextSteps() {
  log.title('üéâ INTEGRA√á√ÉO CONCLU√çDA!');
  
  console.log(`${colors.green}‚úÖ Seu projeto Figma Make est√° conectado com GitHub!${colors.reset}\n`);
  
  console.log(`${colors.cyan}üìã PR√ìXIMOS PASSOS:${colors.reset}\n`);
  
  console.log(`${colors.yellow}1. üîê Configurar Secrets no GitHub:${colors.reset}`);
  console.log(`   - Acesse: Settings ‚Üí Secrets and variables ‚Üí Actions`);
  console.log(`   - Adicione: VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY, VITE_SITE_URL`);
  console.log(`   - Para Vercel: VERCEL_TOKEN, VERCEL_ORG_ID, VERCEL_PROJECT_ID\n`);
  
  console.log(`${colors.yellow}2. üöÄ Configurar Deploy:${colors.reset}`);
  console.log(`   - Vercel: Conecte reposit√≥rio GitHub no dashboard`);
  console.log(`   - Netlify: Conecte reposit√≥rio GitHub no dashboard`);
  console.log(`   - Deploy autom√°tico j√° configurado via GitHub Actions\n`);
  
  console.log(`${colors.yellow}3. üîÑ Configurar Sincroniza√ß√£o Figma Make:${colors.reset}`);
  console.log(`   - Configure FIGMA_MAKE_TOKEN nos secrets do GitHub`);
  console.log(`   - Sincroniza√ß√£o autom√°tica di√°ria j√° configurada`);
  console.log(`   - Execute manual: npm run sync:figma\n`);
  
  console.log(`${colors.yellow}4. üë• Adicionar Colaboradores:${colors.reset}`);
  console.log(`   - Settings ‚Üí Manage access ‚Üí Invite a collaborator\n`);
  
  console.log(`${colors.cyan}üîó LINKS √öTEIS:${colors.reset}`);
  console.log(`   - GitHub: https://github.com`);
  console.log(`   - Vercel: https://vercel.com`);
  console.log(`   - Netlify: https://netlify.com`);
  console.log(`   - Supabase: https://supabase.com\n`);
  
  console.log(`${colors.green}üéØ FLUXO COMPLETO ATIVO:${colors.reset}`);
  console.log(`${colors.cyan}   Figma Make ‚Üí GitHub ‚Üí Actions ‚Üí Deploy ‚Üí Produ√ß√£o üöÄ${colors.reset}\n`);
  
  const openGitHub = await question('üåê Abrir reposit√≥rio no GitHub? (Y/n): ');
  if (openGitHub.toLowerCase() !== 'n') {
    // Tentar abrir URL do reposit√≥rio
    const remoteUrl = execCommand('git remote get-url origin', 'Get remote URL', { silent: true });
    if (remoteUrl.success) {
      const url = remoteUrl.output.trim().replace('.git', '');
      console.log(`${colors.cyan}üîó Reposit√≥rio: ${url}${colors.reset}`);
      
      // Tentar abrir no navegador (funciona no macOS/Linux)
      try {
        execCommand(`open ${url} || xdg-open ${url}`, 'Abrir GitHub', { silent: true });
      } catch (error) {
        // Ignore errors for opening browser
      }
    }
  }
}

// Fun√ß√£o principal
async function main() {
  console.log(`${colors.bold}${colors.green}`);
  console.log('================================================================');
  console.log('üîó INTEGRA√á√ÉO FIGMA MAKE ‚Üí GITHUB');
  console.log('================================================================');
  console.log(`${colors.reset}\n`);
  
  try {
    // 1. Verificar pr√©-requisitos
    const prereqsOK = await checkPrerequisites();
    if (!prereqsOK) {
      log.error('Pr√©-requisitos n√£o atendidos. Instale as depend√™ncias e tente novamente.');
      process.exit(1);
    }
    
    // 2. Configurar Git
    await setupGit();
    
    // 3. Configurar package.json
    await setupPackageJson();
    
    // 4. Criar arquivos de configura√ß√£o
    await createConfigFiles();
    
    // 5. Criar GitHub Actions
    await createGitHubActions();
    
    // 6. Criar templates de issue
    await createIssueTemplates();
    
    // 7. Fazer commit inicial
    await makeInitialCommit();
    
    // 8. Configurar reposit√≥rio remoto
    await setupRemoteRepository();
    
    // 9. Mostrar pr√≥ximos passos
    await showNextSteps();
    
  } catch (error) {
    log.error(`Erro durante integra√ß√£o: ${error.message}`);
    console.error(error);
    process.exit(1);
  } finally {
    rl.close();
  }
}

// Executar se chamado diretamente
if (require.main === module) {
  main();
}

module.exports = { main };